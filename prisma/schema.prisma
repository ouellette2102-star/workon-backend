generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AuditEvent {
  id         String   @id
  userId     String?
  action     String
  resource   String
  resourceId String?
  metadata   Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())
  user       User?    @relation(fields: [userId], references: [id])

  @@index([createdAt])
  @@index([resource, resourceId])
  @@index([userId])
  @@map("audit_events")
}

model Category {
  id                 String    @id
  name               String    @unique
  nameEn             String?
  icon               String?
  legalNotes         String?
  residentialAllowed Boolean   @default(true)
  createdAt          DateTime  @default(now())
  missions           Mission[]
  skills             Skill[]

  @@map("categories")
}

model ClientOrg {
  id                 String             @id
  ownerId            String
  type               ClientOrgType
  name               String
  logoUrl            String?
  billingAddress     Json?
  taxNumbers         Json?
  verificationStatus VerificationStatus @default(PENDING)
  createdAt          DateTime           @default(now())
  updatedAt          DateTime
  owner              User               @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  missions           Mission[]

  @@index([ownerId])
  @@map("client_orgs")
}

model ComplianceDocument {
  id         String                 @id
  userId     String
  type       ComplianceDocumentType
  version    String
  acceptedAt DateTime
  createdAt  DateTime               @default(now())
  user       User                   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([type])
  @@index([userId])
  @@map("compliance_documents")
}

model Dispute {
  id         String        @id
  missionId  String        @unique
  openedById String
  reason     String
  status     DisputeStatus @default(OPEN)
  resolution String?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime
  mission    Mission       @relation(fields: [missionId], references: [id], onDelete: Cascade)
  openedBy   User          @relation(fields: [openedById], references: [id], onDelete: Cascade)
  
  // PR-00: Trust foundation relations
  evidence   DisputeEvidence[]
  timeline   DisputeTimeline[]

  @@index([status])
  @@map("disputes")
}

model LocalMission {
  id                    String             @id
  title                 String
  description           String
  category              String
  status                LocalMissionStatus @default(open)
  price                 Float
  latitude              Float
  longitude             Float
  city                  String
  address               String?
  createdByUserId       String
  assignedToUserId      String?
  createdAt             DateTime           @default(now())
  updatedAt             DateTime
  // PR-6: Payment fields
  paidAt                DateTime?
  stripePaymentIntentId String?
  assignedToUser        LocalUser?         @relation("local_missions_assignedToUserIdTolocal_users", fields: [assignedToUserId], references: [id])
  createdByUser         LocalUser          @relation("local_missions_createdByUserIdTolocal_users", fields: [createdByUserId], references: [id], onDelete: Cascade)
  offers                LocalOffer[]

  @@index([assignedToUserId])
  @@index([category])
  @@index([city])
  @@index([createdByUserId])
  @@index([latitude, longitude])
  @@index([status])
  @@index([stripePaymentIntentId])
  @@map("local_missions")
}

// ============================================
// LOCAL OFFERS - Offres pour missions locales
// ============================================

model LocalOffer {
  id          String           @id
  missionId   String
  workerId    String
  price       Float
  message     String?
  status      LocalOfferStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime

  // Relations
  mission LocalMission @relation(fields: [missionId], references: [id], onDelete: Cascade)
  worker  LocalUser    @relation(fields: [workerId], references: [id], onDelete: Cascade)

  // Unique constraint: one offer per worker per mission
  @@unique([missionId, workerId])
  @@index([missionId])
  @@index([workerId])
  @@index([status])
  @@map("local_offers")
}

enum LocalOfferStatus {
  PENDING
  ACCEPTED
  DECLINED
}

model LocalUser {
  id               String         @id
  email            String         @unique
  hashedPassword   String
  firstName        String
  lastName         String
  phone            String?
  city             String?
  pictureUrl       String?        // Profile picture URL
  role             LocalUserRole  @default(worker)
  active           Boolean        @default(true)
  deletedAt        DateTime?      // GDPR: timestamp of account deletion
  createdAt        DateTime       @default(now())
  updatedAt        DateTime
  assignedMissions LocalMission[] @relation("local_missions_assignedToUserIdTolocal_users")
  createdMissions  LocalMission[] @relation("local_missions_createdByUserIdTolocal_users")
  offers           LocalOffer[]

  @@index([active])
  @@index([city])
  @@index([email])
  @@index([role])
  @@index([deletedAt])
  @@map("local_users")
}

model Mission {
  id               String         @id
  authorClientId   String
  assigneeWorkerId String?
  clientOrgId      String?
  title            String
  description      String
  categoryId       String
  requiredSkills   String[]       @default([])
  locationLat      Float
  locationLng      Float
  locationAddress  String?
  priceType        String
  budgetMin        Float
  budgetMax        Float
  status           MissionStatus  @default(DRAFT)
  startAt          DateTime?
  endAt            DateTime?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime
  deletedAt        DateTime?
  workerProfileId  String?
  dispute          Dispute?
  assigneeWorker   User?          @relation("missions_assigneeWorkerIdTousers", fields: [assigneeWorkerId], references: [id])
  authorClient     User           @relation("missions_authorClientIdTousers", fields: [authorClientId], references: [id], onDelete: Cascade)
  category         Category       @relation(fields: [categoryId], references: [id])
  clientOrg        ClientOrg?     @relation(fields: [clientOrgId], references: [id])
  workerProfile    WorkerProfile? @relation(fields: [workerProfileId], references: [id])
  offers           Offer[]
  payments         Payment[]
  reviews          Review[]
  messages         Message[]
  contract         Contract?
  photos           MissionPhoto[]
  events           MissionEvent[]

  @@index([assigneeWorkerId])
  @@index([authorClientId])
  @@index([categoryId])
  @@index([deletedAt])
  @@index([locationLat, locationLng])
  @@index([status])
  @@index([workerProfileId])
  @@map("missions")
}

model Notification {
  id          String    @id
  userId      String
  type        String
  payloadJSON Json
  readAt      DateTime?
  createdAt   DateTime  @default(now())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([readAt])
  @@index([userId])
  @@map("notifications")
}

model Offer {
  id            String        @id
  missionId     String
  workerId      String
  message       String?
  proposedRate  Float
  eta           String?
  status        OfferStatus   @default(PENDING)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime
  mission       Mission       @relation(fields: [missionId], references: [id], onDelete: Cascade)
  workerProfile WorkerProfile @relation(fields: [workerId], references: [id], onDelete: Cascade)

  @@index([missionId])
  @@index([status])
  @@index([workerId])
  @@map("offers")
}

model Payment {
  id                     String        @id
  missionId              String        @unique
  stripePaymentIntentId  String?       @unique
  stripeConnectAccountId String?
  amount                 Float
  currency               String        @default("CAD")
  platformFeePct         Float         @default(10)
  status                 PaymentStatus @default(CREATED)
  lastStripeEventId      String?
  createdAt              DateTime      @default(now())
  updatedAt              DateTime
  mission                Mission       @relation(fields: [missionId], references: [id], onDelete: Cascade)

  @@index([missionId])
  @@index([status])
  @@map("payments")
}

model Review {
  id           String           @id
  authorId     String
  targetUserId String
  missionId    String?
  rating       Int
  comment      String?
  moderation   ReviewModeration @default(OK)
  createdAt    DateTime         @default(now())
  updatedAt    DateTime
  author       User             @relation("reviews_authorIdTousers", fields: [authorId], references: [id], onDelete: Cascade)
  mission      Mission?         @relation(fields: [missionId], references: [id])
  targetUser   User             @relation("reviews_targetUserIdTousers", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@index([missionId])
  @@index([moderation])
  @@index([targetUserId])
  @@map("reviews")
}

model Skill {
  id             String        @id
  name           String
  nameEn         String?
  categoryId     String
  requiresPermit Boolean       @default(false)
  proofType      String?
  createdAt      DateTime      @default(now())
  category       Category      @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  workerSkills   WorkerSkill[]

  @@unique([name, categoryId])
  @@map("skills")
}

model Subscription {
  id                   String             @id
  userId               String
  plan                 SubscriptionPlan   @default(FREE)
  stripeSubscriptionId String?            @unique
  startedAt            DateTime           @default(now())
  renewsAt             DateTime?
  status               SubscriptionStatus @default(ACTIVE)
  createdAt            DateTime           @default(now())
  updatedAt            DateTime
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([userId])
  @@map("subscriptions")
}

model UserProfile {
  id        Int      @id @default(autoincrement())
  userId    String   @unique
  role      UserRole
  name      String
  phone     String
  city      String
  createdAt DateTime @default(now())
  updatedAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model User {
  id                  String               @id
  clerkId             String               @unique
  createdAt           DateTime             @default(now())
  updatedAt           DateTime
  auditEvents         AuditEvent[]
  clientOrgs          ClientOrg[]
  complianceDocuments ComplianceDocument[]
  disputes            Dispute[]
  assignedMissions    Mission[]            @relation("missions_assigneeWorkerIdTousers")
  authoredMissions    Mission[]            @relation("missions_authorClientIdTousers")
  notifications       Notification[]
  authoredReviews     Review[]             @relation("reviews_authorIdTousers")
  receivedReviews     Review[]             @relation("reviews_targetUserIdTousers")
  subscriptions       Subscription[]
  userProfile         UserProfile?
  workerProfile       WorkerProfile?
  sentMessages        Message[]
  employerContracts   Contract[]           @relation("contracts_employerIdTousers")
  workerContracts     Contract[]           @relation("contracts_workerIdTousers")
  devices             Device[]

  @@map("users")
}

/// Device registration for push notifications
model Device {
  id         String   @id @default(uuid())
  userId     String
  deviceId   String   // Unique device identifier (vendor ID, etc.)
  platform   String   // ios, android, web
  pushToken  String?  // FCM/APNs token
  appVersion String?
  active     Boolean  @default(true)
  lastSeenAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceId])
  @@index([userId])
  @@index([active])
  @@map("devices")
}

model WorkerProfile {
  id                 String         @id
  userId             String         @unique
  hourlyRate         Float
  serviceAreas       Json?
  residentialEnabled Boolean        @default(false)
  portfolio          Json[]         @default([])
  availability       Json?
  completedMissions  Int            @default(0)
  totalEarnings      Float          @default(0)
  createdAt          DateTime       @default(now())
  updatedAt          DateTime
  missions           Mission[]
  offers             Offer[]
  user               User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  workerSkills       WorkerSkill[]

  @@map("worker_profiles")
}

model WorkerSkill {
  id            String        @id
  workerId      String
  skillId       String
  verified      Boolean       @default(false)
  proofUrl      String?
  createdAt     DateTime      @default(now())
  skill         Skill         @relation(fields: [skillId], references: [id], onDelete: Cascade)
  workerProfile WorkerProfile @relation(fields: [workerId], references: [id], onDelete: Cascade)

  @@unique([workerId, skillId])
  @@map("worker_skills")
}

enum ClientOrgType {
  BUSINESS
  RESIDENTIAL
}

enum ComplianceDocumentType {
  TERMS
  PRIVACY
  CONTRACT
  POLICY_LAW25
}

enum DisputeStatus {
  OPEN
  IN_MEDIATION
  RESOLVED
  CLOSED
}

enum LocalMissionStatus {
  open
  assigned
  in_progress
  completed
  paid
  cancelled
}

enum LocalUserRole {
  worker
  employer
  residential_client
}

enum MissionStatus {
  DRAFT
  OPEN
  MATCHED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum OfferStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum PaymentStatus {
  CREATED
  REQUIRES_ACTION
  AUTHORIZED
  CAPTURED
  CANCELED
  FAILED
  SUCCEEDED
  REFUNDED
  DISPUTED
}

enum ReviewModeration {
  OK
  FLAGGED
}

enum SubscriptionPlan {
  FREE
  PRO
  PREMIUM
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
}

enum UserRole {
  WORKER
  EMPLOYER
  RESIDENTIAL
  ADMIN
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

// ============================================
// MESSAGES MODULE - Chat entre Worker et Employer
// ============================================

model Message {
  id         String            @id
  missionId  String
  senderId   String
  senderRole MessageSenderRole
  content    String
  status     MessageStatus     @default(SENT)
  createdAt  DateTime          @default(now())
  
  // Relations
  mission    Mission           @relation(fields: [missionId], references: [id], onDelete: Cascade)
  sender     User              @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([missionId])
  @@index([senderId])
  @@index([createdAt])
  @@map("messages")
}

enum MessageSenderRole {
  WORKER
  EMPLOYER
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
}

// ============================================
// CONTRACTS MODULE - Contrats de mission
// ============================================

model Contract {
  id              String         @id
  missionId       String         @unique
  employerId      String
  workerId        String
  status          ContractStatus @default(DRAFT)
  amount          Float
  hourlyRate      Float?
  startAt         DateTime?
  endAt           DateTime?
  signedByWorker  Boolean        @default(false)
  signedByEmployer Boolean       @default(false)
  signatureNonce  String?
  contractUrl     String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  // Relations
  mission         Mission        @relation(fields: [missionId], references: [id], onDelete: Cascade)
  employer        User           @relation("contracts_employerIdTousers", fields: [employerId], references: [id], onDelete: Cascade)
  worker          User           @relation("contracts_workerIdTousers", fields: [workerId], references: [id], onDelete: Cascade)

  @@index([employerId])
  @@index([workerId])
  @@index([status])
  @@map("contracts")
}

enum ContractStatus {
  DRAFT
  PENDING
  ACCEPTED
  REJECTED
  COMPLETED
  CANCELLED
}

// ============================================
// MISSION PHOTOS - Photos uploadées par Worker/Employer
// ============================================

model MissionPhoto {
  id           String   @id @default(cuid())
  missionId    String
  userId       String
  url          String
  path         String?
  mimeType     String?
  size         Int?
  originalName String?
  createdAt    DateTime @default(now())

  // Relations
  mission Mission @relation(fields: [missionId], references: [id], onDelete: Cascade)

  @@index([missionId])
  @@index([userId])
  @@map("mission_photos")
}

// ============================================
// MISSION EVENTS - Journal d'événements (audit + notifications)
// ============================================

enum MissionEventType {
  MISSION_CREATED
  MISSION_PUBLISHED
  MISSION_ACCEPTED
  MISSION_STARTED
  MISSION_COMPLETED
  MISSION_CANCELED
  MISSION_EXPIRED
  PAYMENT_AUTHORIZED
  PAYMENT_CAPTURED
  PAYMENT_CANCELED
  PHOTO_UPLOADED
  OFFER_SUBMITTED
  OFFER_ACCEPTED
  OFFER_DECLINED
}

model MissionEvent {
  id           String           @id @default(cuid())
  missionId    String
  type         MissionEventType
  actorUserId  String?          // Qui a causé l'action (employer/worker/system)
  targetUserId String?          // User concerné pour "feed" (l'autre partie)
  payload      Json?            // Détails non sensibles (ex: {fromStatus, toStatus})
  createdAt    DateTime         @default(now())

  // Relations
  mission Mission @relation(fields: [missionId], references: [id], onDelete: Cascade)

  @@index([missionId, createdAt])
  @@index([targetUserId, createdAt])
  @@index([type, createdAt])
  @@map("mission_events")
}

// ============================================
// INVOICES - Factures pour paiements (source of truth)
// ============================================

model Invoice {
  id                       String        @id @default(cuid())
  missionId                String?       // Null si LocalMission
  localMissionId           String?       // Null si Mission
  payerUserId              String        // Qui paye (employer/client)
  payerLocalUserId         String?       // Si LocalUser
  
  // Montants (en centimes pour précision)
  subtotalCents            Int           // Montant de base (prix mission)
  platformFeeCents         Int           // Frais WorkOn
  taxesCents               Int           @default(0)  // TPS/TVQ si applicable
  totalCents               Int           // Total à payer
  currency                 String        @default("CAD")
  
  // Stripe
  stripeCheckoutSessionId  String?       @unique
  stripePaymentIntentId    String?
  
  // Status
  status                   InvoiceStatus @default(PENDING)
  paidAt                   DateTime?
  
  // Metadata
  description              String?
  metadata                 Json?
  
  createdAt                DateTime      @default(now())
  updatedAt                DateTime      @updatedAt

  @@index([missionId])
  @@index([localMissionId])
  @@index([payerUserId])
  @@index([status])
  @@index([stripeCheckoutSessionId])
  @@map("invoices")
}

enum InvoiceStatus {
  PENDING     // En attente de paiement
  PROCESSING  // Checkout en cours
  PAID        // Payé avec succès
  FAILED      // Échec du paiement
  CANCELLED   // Annulé
  REFUNDED    // Remboursé
}

// ============================================
// STRIPE EVENTS - Idempotence pour webhooks
// ============================================

model StripeEvent {
  id          String   @id  // Stripe event ID (evt_xxx)
  type        String        // Type d'event (payment_intent.succeeded, etc.)
  processed   Boolean  @default(false)
  processedAt DateTime?
  payload     Json?         // Payload complet (optionnel, pour debug)
  error       String?       // Message d'erreur si échec
  createdAt   DateTime @default(now())

  @@index([type, processed])
  @@map("stripe_events")
}

// ============================================
// EMAIL OTP - For email change verification
// ============================================

model EmailOtp {
  id         String    @id @default(cuid())
  userId     String    // LocalUser ID
  newEmail   String    // New email to verify
  codeHash   String    // HMAC-SHA256 hash of OTP code
  expiresAt  DateTime  // Expiration time (10 min default)
  attempts   Int       @default(0)  // Failed attempts count
  consumedAt DateTime? // When OTP was successfully used
  ip         String?   // Request IP for audit
  userAgent  String?   // Request user agent for audit
  createdAt  DateTime  @default(now())

  @@index([userId, newEmail])
  @@index([expiresAt])
  @@map("email_otp")
}

// ============================================
// PR-00: CORE TRUST FOUNDATION
// Support Tickets, Dispute Evidence, Device Tracking
// ============================================

/// Support tickets for in-app customer support
model SupportTicket {
  id          String              @id @default(cuid())
  userId      String              // User who opened the ticket
  missionId   String?             // Related mission (optional)
  subject     String
  description String
  category    SupportTicketCategory
  priority    SupportTicketPriority @default(NORMAL)
  status      SupportTicketStatus   @default(OPEN)
  assignedTo  String?             // Admin user ID (if assigned)
  resolvedAt  DateTime?
  metadata    Json?               // Additional context
  
  // Device/request context for fraud detection
  deviceId    String?             // Hashed device ID
  ipAddress   String?
  userAgent   String?
  
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  // Relations
  messages    SupportTicketMessage[]

  @@index([userId])
  @@index([status])
  @@index([category])
  @@index([missionId])
  @@index([createdAt])
  @@map("support_tickets")
}

/// Messages within a support ticket
model SupportTicketMessage {
  id          String   @id @default(cuid())
  ticketId    String
  senderId    String   // User or admin ID
  senderType  String   // "user" or "admin"
  content     String
  attachments Json?    // Array of attachment URLs
  createdAt   DateTime @default(now())

  // Relations
  ticket      SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@map("support_ticket_messages")
}

enum SupportTicketCategory {
  PAYMENT
  MISSION
  ACCOUNT
  TECHNICAL
  DISPUTE
  OTHER
}

enum SupportTicketPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum SupportTicketStatus {
  OPEN
  IN_PROGRESS
  WAITING_USER
  WAITING_ADMIN
  RESOLVED
  CLOSED
}

/// Evidence attached to disputes (photos, videos, documents)
model DisputeEvidence {
  id          String              @id @default(cuid())
  disputeId   String
  uploadedBy  String              // User ID who uploaded
  type        DisputeEvidenceType
  url         String              // Storage URL
  filename    String?
  mimeType    String?
  size        Int?                // File size in bytes
  description String?             // User description
  metadata    Json?               // EXIF, location, timestamp
  
  // Moderation
  reviewed    Boolean             @default(false)
  reviewedBy  String?             // Admin who reviewed
  reviewedAt  DateTime?
  flagged     Boolean             @default(false)
  flagReason  String?
  
  createdAt   DateTime            @default(now())

  // Relations
  dispute     Dispute             @relation(fields: [disputeId], references: [id], onDelete: Cascade)

  @@index([disputeId])
  @@index([uploadedBy])
  @@index([reviewed])
  @@map("dispute_evidence")
}

enum DisputeEvidenceType {
  PHOTO
  VIDEO
  DOCUMENT
  SCREENSHOT
  OTHER
}

/// Timeline of actions/events in a dispute
model DisputeTimeline {
  id          String              @id @default(cuid())
  disputeId   String
  action      DisputeAction
  actorId     String?             // User or admin who performed action
  actorType   String?             // "user", "admin", "system"
  details     String?             // Human-readable description
  metadata    Json?               // Additional structured data
  createdAt   DateTime            @default(now())

  // Relations
  dispute     Dispute             @relation(fields: [disputeId], references: [id], onDelete: Cascade)

  @@index([disputeId, createdAt])
  @@map("dispute_timeline")
}

enum DisputeAction {
  OPENED
  EVIDENCE_ADDED
  ASSIGNED
  STATUS_CHANGED
  MESSAGE_SENT
  ESCALATED
  RESOLVED
  CLOSED
  REOPENED
}

/// Audit log for sensitive operations (price changes, payments, admin actions)
model TrustAuditLog {
  id            String          @id @default(cuid())
  category      AuditCategory
  action        String          // Specific action (e.g., "price_changed", "payment_captured")
  actorId       String?         // User or admin who performed action
  actorType     String?         // "user", "admin", "system", "webhook"
  targetType    String?         // "mission", "payment", "user", etc.
  targetId      String?
  
  // Before/after state for sensitive changes
  previousValue Json?
  newValue      Json?
  
  // Context
  reason        String?         // Why the action was taken
  ipAddress     String?
  userAgent     String?
  deviceId      String?         // Hashed device ID
  correlationId String?         // Request correlation ID
  
  // Risk signals
  riskScore     Int?            // 0-100 risk assessment
  flagged       Boolean         @default(false)
  
  createdAt     DateTime        @default(now())

  @@index([category, createdAt])
  @@index([actorId])
  @@index([targetType, targetId])
  @@index([flagged])
  @@map("trust_audit_logs")
}

enum AuditCategory {
  PRICE_CHANGE
  PAYMENT
  MISSION_STATUS
  USER_ACCOUNT
  ADMIN_ACTION
  SECURITY
  DISPUTE
  REFUND
}
